<html>
<head><script>(function(w,i,g){w[g]=w[g]||[];if(typeof w[g].push=='function')w[g].push(i)})
(window,'AW-1055364430','google_tags_first_party');</script><script async src="/925q/"></script>
			<script>
				window.dataLayer = window.dataLayer || [];
				function gtag(){dataLayer.push(arguments);}
				gtag('js', new Date());
				gtag('set', 'developer_id.dYzg1YT', true);
				gtag('config', 'AW-1055364430');
			</script>
			
<!--Meta stuff-->
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"/>
<script type="text/javascript" src="js/lagged.js"></script>
<title>Move People</title>
<style>
    * {
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        font-family: sans-serif;
        font-weight: 400;
        outline: none;
        user-select: none;
    }
    body {
        margin: 0;
        overflow: hidden;
    }
    #loading {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        color: white;
        text-align: center;
        font-size: 30px;
        font-weight: 100;
        background-color: #4153A5;
        text-shadow:         /* create a black outline */
        -1px -1px 0 #000,
         0   -1px 0 #000,
         1px -1px 0 #000,
         1px  0   0 #000,
         1px  1px 0 #000,
         0    1px 0 #000,
        -1px  1px 0 #000,
        -1px  0   0 #000;

    }
    #loading>div {
        margin-top: 30vh;
    }
    .progress {
        margin-top: 1vh;
        display: inline-block;
        border-radius: 10vw;
        width: 50vw;
        height: 1.5vw;
        background-color: #2B292A;
    }
    #progressbar {
        width: 0;
        border-radius: 10vw;
        height: 1.5vw;
        background: rgb(253,105,41);
        background: -moz-linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);
        background: -webkit-linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);
        background: linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);
        filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#fd6929",endColorstr="#f4c029",GradientType=1);
    }
    #lagged {
        margin-bottom: 10vh;
        display: inline-block;
        width: 30vh;
        height: 30vh;
        background-image: url(Images/lagged.png);
        background-repeat: no-repeat;
        background-size:contain;
    }
    #c {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: block;
    }
    #loaderPlayButton {
        position: fixed;
        left: 50%;
        bottom: 10px;
        transform:translateX(-50%);
        background-image: url(Images/btnPlay.png);
        background-repeat: no-repeat;
        background-size:contain;
        width: 400px;
        height: 180px;
        visibility: hidden;
    }

    /* IN-GAME UI */
    #gameUI {
        position: fixed;
        text-align: center;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        visibility: hidden;
    }
    #ingameLagged {
        display: inline-block;
        width: 22vh;
        height: 11vh;
        background-image: url(Images/lagged2.png);
        background-repeat: no-repeat;
        background-size:contain;
        margin-top: -18px;
    }
    #lvlNo {
        display: inline-block;
        margin-top: -1.7vh;
        text-align: center;
        color: white;
        font-size: 170%;
        font-weight: 800;
        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,         /* create a black outline */
        -1px -1px 0 #000,
         0   -1px 0 #000,
         1px -1px 0 #000,
         1px  0   0 #000,
         1px  1px 0 #000,
         0    1px 0 #000,
        -1px  1px 0 #000,
        -1px  0   0 #000;
    }
    #levelProgressContainer {
        display: inline-block;
        border-radius: 0.65vw;
        width: 300px;
        height: 16px;
        background-color: #365D66;
        box-shadow: 0 0 11px 4px rgb(0 0 0 / 54%);
        outline: white solid 4px;
        margin-top: 1px;

    }
    #levelProgressbar {
        width: 0px;
        border-radius: inherit;
        height: inherit;
        transition-duration: 0.2s;
        background: #59BB83;
    }
    /* END */


    /* GAME-OVER UI */
    #gameOverUI {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        text-align: center;
        visibility: hidden;
        background-color: rgba(0,0,0,0.5);
    }
    #moreGames {
        display: inline-block;
        width: 400px;
        height: 400px;
        background-color: rgba(0,0,0,0.5);
        color: white;
        margin-top: -25px;
        text-align: center;
        padding: 10px;
    }
    #moreGames h3{
        float: left;
        clear: both;
        width: 100%;
        line-height: 19px;
        height: 19px;
        font-size: 17px;
        font-weight: 600;
        margin: 0 0 5px 0;
    }
    .thumbWrapper {
        overflow: hidden;
        position: relative;
        background-color: #a5a5a5;
        box-shadow: 0 0 4px 0 rgb(0 0 0 / 50%);
        margin: 1% 2% 1% 2.6%;
        width: 45%;
        border-radius: 5px;
        float: left;
        display: block;
    }
    .thumbWrapper a {
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        z-index: 200;
        display: block;
        float: left;
        width: 100%;
    }
    .thumbWrapper img {
        width: 100%;
        height: auto;
        border-radius: 2px;
    }
    .thumbWrapper span.thumbname{
        position:absolute;transition:bottom .25s ease;font-size:15px;font-weight:700;letter-spacing:1px;width:100%;bottom:-125%;left:0;height:auto;min-height:18px;line-height:20px;padding:7px 0 4px;text-align:center;text-transform:uppercase;background-color:rgba(42,100,144,.8);color:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px
    }
    .thumbWrapper:hover span.thumbname{
        bottom: -1%;
    }
    #btnNext{
        display: inline-block;
        margin-top: 14vh;
        background-image: url(Images/btnNextLevel.png);
        background-repeat: no-repeat;
        background-size:contain;
        width: 300px;
        height: 140px;
    }
    #btnRestart{
        display: inline-block;
        margin-top: 14vh;
        background-image: url(Images/btnRestart.png);
        background-repeat: no-repeat;
        background-size:contain;
        width: 300px;
        height: 140px;
    }
    #goMessage {
        color: white;
        font-size: 300%;
        font-weight: 800;

        display: inline-block;
        margin-top: 1%;
        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,
        -1px -1px 0 #000,
         0   -1px 0 #000,
         1px -1px 0 #000,
         1px  0   0 #000,
         1px  1px 0 #000,
         0    1px 0 #000,
        -1px  1px 0 #000,
        -1px  0   0 #000;
    }
    /* END */


    /*SEPERATE THEN GAME AND GAMEOVER UI BUTTONS*/
    #btnSound {
        position: fixed;
        left: 0.5%;
        top: 1%;
        width: 8%;
        height: 8%;
        visibility: hidden;
        background-image: url(Images/btnSound.png);
        background-repeat: no-repeat;
        background-size:contain;
    }
    .button {
        transition: all .1s;
        cursor: pointer;
        user-select: none;
    }
    .button:hover {
        transform: scale(1.1);
    }
    /* END */

    /*RESPONSIVE*/
    /*for desktop screens*/
    #coverLeft {
        position: fixed;
        left: 0;
        top: 0;
        width: 35%;
        height: 100%;
        background: black;
        pointer-events: none;
    }
    #coverRight {
        position: fixed;
        right: 0;
        top: 0;
        width: 35%;
        height: 100%;
        background: black;
        pointer-events: none;
    }

    /*Portrait mode*/
    #rotateDeviceBG {
        background-color: rgba(0,0,0,1);
        position: fixed;
        width: 100%;
        height: 100%;
        text-align: center;
        visibility: hidden;
    }
    .phone {
        margin-top: 20%;
        display: inline-block;
        height: 100px;
        width: 200px;
        border: 4px solid white;
        border-radius: 10px;
        animation: rotate 1.5s ease-in-out infinite alternate;
    }
    .message {
        position: fixed;
        width: 100%;
        height: 10%;
        left: 0;
        text-align: center;
        color: white;
        font-size: 200%;
        font-weight: 800;
        bottom: 10%;
      /* display: none; */
    }
    @keyframes rotate {
      0% {
            transform: rotate(0deg)
        }
        50% {
            transform: rotate(-90deg)
        }
        100% {
            transform: rotate(-90deg)
        }
    }
    @media only screen and (max-width: 900px) {
        #loading {
            font-size: 20px;
        }
        .progress {
            width: 70vw;
        }
        #coverLeft {
            display: none;
        }
        #coverRight {
            display: none;
        }
        #btnSound {
            width: 11%;
            height: 11%;
        }
        #loaderPlayButton {
            bottom: 0px;
            width: 250px;
            height: 110px;
        }
        /* END */

        /* GAME-UI */
        /* #lvlNo {
            font-size: 170%;
            font-weight: 800;
        } */
        #ingameLagged {
            width: 17vh;
            height: 9vh;
            margin-top: -10px;
        }
        #levelProgressContainer {
            border-radius: 8.5px;
            width: 250px;
        }
        /* END */

        /* GAME-OVER UI */
        #moreGames {
            width: 350px;
            height: 350px;
            margin-top: 5%;
        }
        #goMessage {
            font-size: 250%;
            font-weight: 700;
            margin-top: 10%;
        }
        #btnNext{
            width: 200px;
            height: 90px;
            margin-top: 12vh;
        }
        #btnRestart{
            width: 200px;
            height: 90px;
            margin-top: 12vh;
        }
        /* END */
    }
    @media only screen and (max-width: 1600px) {
        #coverLeft {
            width: 30%;
        }
        #coverRight {
            width: 30%;
        }
    }
    @media only screen and (max-width: 1200px) {
        #coverLeft {
            width: 25%;
        }
        #coverRight {
            width: 25%;
        }
    }
    /* For very small iphone 5 and SE vertical display with tabs bar, since I have one */
    @media only screen and (max-height: 670px) {
        #moreGames {
            margin-top: -5%;
        }
        #goMessage {
            margin-top: 15px;
        }
        #btnNext{
            margin-top: 10vh;
        }
        #btnRestart{
            margin-top: 10vh;
        }
        #lvlNo {
            font-size: 140%;
        }
        #levelProgressContainer {
            border-radius: 6px;
            width: 200px;
            /* height: 17px; */
            /* margin-top: 9px; */
        }
    }

</style>

</head>
<body>
<script src="./Libs/three.min.js"></script>
<script src="./Libs/FBXLoader.js"></script>
<script src="./Libs/inflate.min.js"></script>
<script src="./Libs/SkeletonUtils.js"></script>
<script src="./Libs/confetti.browser.js"></script>

<div id="loading">
    <div>
        <div id="lagged"></div>
        <div id="progressText">0%</div>
        <div class="progress"><div id="progressbar"></div></div>
        <div id="loadddi">Loading...</div>
    </div>
</div>

<canvas id="c"></canvas>
<div id="loaderPlayButton" onclick="btnLoader()" class="button"></div>

<div id="gameUI">
    <div id="ingameLagged"></div><br>
    <div id="lvlNo">Level 1</div><br>
    <div id="levelProgressContainer">
        <div id="levelProgressbar"></div>
    </div>
    <br>
</div>

<div id="gameOverUI">
    <div id="btnRestart" onclick="btnGO()" class="animate__animated animate__rubberBand animate__infinite animate__slow button"></div><br>
    <div id="btnNext" onclick="btnGO()" class="animate__animated animate__rubberBand animate__infinite animate__slow button"></div>
    <br>
    <div id="goMessage" class="animate__animated animate__tada animate__infinite">Level Complete!</div><br>
</div>

<div id="coverLeft"></div>
<div id="coverRight"></div>
<div id="btnSound"  class="button" onclick="btnSound()"></div>

<div id="rotateDeviceBG">
    <div class="phone">
    </div>
    <div class="message">
      Please rotate your device!
    </div>
</div>

<script>
// GLOBAL VAR
console.warn = function(){};
var scene = null;
var camera = null;
var renderer = null;
var clock = new THREE.Clock();
var onMobile = false;

// RESETABLE VARS
var player = null;
var gameOver = false;
var level = 1;

//save
var loadSave = null;
try{
    loadSave = parseInt(localStorage.getItem("MovePeopleLaggedSavedd"));
}catch(e){
    console.log(e);
}
if (loadSave){
    level = loadSave;
}

// RESETABLE ARRAYS
var updateArray = [];

const BaseModel = {
    model1: {url: 'Models/model1.fbx'},
    model1_1: {url: 'Models/model1_1.fbx'},
    model2: {url: 'Models/model2.fbx'},
    model5: {url: 'Models/model5.fbx'},
    model6: {url: 'Models/model6.fbx'},
    model8: {url: 'Models/model8.fbx'},
    model8_8: {url: 'Models/model8_8.fbx'},
    model9: {url: 'Models/model9.fbx'},
    model10: {url: 'Models/model10.fbx'},
    model11: {url: 'Models/model11.fbx'},
}
const Anims = {
    f_idle: {url: 'Models/a_f_idle.fbx'},
    f_photo: {url: 'Models/a_f_photo.fbx'},
    f_proposed: {url: 'Models/a_f_proposed.fbx'},
    f_kiss: {url: 'Models/a_f_kiss.fbx'},
    f_sit: {url: 'Models/a_f_sit.fbx'},
    f_office: {url: 'Models/a_f_office.fbx'},
    f_booty: {url: 'Models/a_f_booty.fbx'},
    f_float: {url: 'Models/a_f_float.fbx'},
    f_pose2: {url: 'Models/a_f_pose2.fbx'},

    m_idle: {url: 'Models/a_m_idle.fbx'},
    m_propose: {url: 'Models/a_m_propose.fbx'},
    m_sit: {url: 'Models/a_m_sit.fbx'},
    m_yoga: {url: 'Models/a_m_yoga.fbx'},
    m_police: {url: 'Models/a_m_police.fbx'},
    m_policeConvict: {url: 'Models/a_m_policeConvict.fbx'},
    m_exercise: {url: 'Models/a_m_exercise.fbx'},
}
const Textures = {
    circle: {url: 'Images/circle.png'},
    hand: {url: 'Images/hand.png'},
}
const Sound = {
    music: {url: 'Sound/music.mp3'},
    button: {url: 'Sound/button.mp3'},
    levelComplete: {url: 'Sound/levelComplete.mp3'},
}

// DOM elements
const CANVAS = document.querySelector('#c');
const PROGRESS_TEXT = document.querySelector('#progressText');
const LOADER_BUTTON  = document.querySelector('#loaderPlayButton');

// IN_GAME
const GAME_UI = document.querySelector('#gameUI');
const LEVEL_TEXT = document.querySelector('#lvlNo');
const PROGRESS_BAR = document.querySelector('#levelProgressbar');

// GAME_OVER
const GAMEOVER_UI = document.querySelector('#gameOverUI');
const GO_MESSAGE = document.querySelector('#goMessage');
const BTN_RESTART = document.querySelector('#btnRestart');
const BTN_NEXT = document.querySelector('#btnNext');

// MISC
const COVER_LEFT  = document.querySelector('#coverLeft');
const COVER_RIGHT  = document.querySelector('#coverRight');
const BTN_SOUND = document.querySelector('#btnSound');
const ROTATE_MSG  = document.querySelector('#rotateDeviceBG');

function preload() {
    const progressbarElem = document.querySelector('#progressbar');
    let manager = new THREE.LoadingManager();
    manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
        //console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
    };
    manager.onLoad = function ( ) {
        //console.log( 'Loading complete!');
        //init();
        // hide the loading bar
        //const loadingElem = document.querySelector('#loading');
        //loadingElem.style.display = 'none';
        LaggedAPI.init();
        LOADER_BUTTON.style.visibility = "visible";

        document.getElementById('loadddi').style.visibility="hidden";
            document.getElementById('progressText').style.visibility="hidden";
    };
    manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        //console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
        progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;
        PROGRESS_TEXT.innerHTML = `${itemsLoaded / itemsTotal * 100 | 0}%`;
    };
    manager.onError = function ( url ) {
        //console.log( 'There was an error loading ' + url );
    };

    var loader = new THREE.FBXLoader( manager );
    // load base character model
    for (const model of Object.values(BaseModel)) {
        loader.load( model.url, function ( fbx ) {
            model.fbx = fbx;
        });
    }
    // load anims
    for (const model of Object.values(Anims)) {
        loader.load( model.url, function ( fbx ) {
            //model.fbx = fbx;
            model.animation = fbx.animations[ 0 ];
        });
    }
    // load textures
    var loaderTex = new THREE.TextureLoader(manager);
    for (const img of Object.values(Textures)) {
        loaderTex.load( img.url, function(texture) {
            texture.encoding = THREE.sRGBEncoding;
            img.texture = texture;
        });
    }
    // load audio
    Sound.listener = new THREE.AudioListener();
    const audioLoader = new THREE.AudioLoader( manager );
    for (const key of Object.values(Sound)) {
        audioLoader.load( key.url, function(buffer) {
            key.sound = new THREE.Audio( Sound.listener );
            key.sound.setBuffer( buffer );
            key.sound.setVolume( 1.5 );
            if (key.url == 'Sound/music.mp3'){
                key.sound.setLoop( true );
                key.sound.setVolume( 1 );
            }
        });
    }
}

function init(){
    if (is_touch_device()){
        onMobile = true;
        COVER_LEFT.style.display = 'none';
        COVER_RIGHT.style.display = 'none';
    }
    BTN_SOUND.style.visibility = "visible";
    GAME_UI.style.visibility = "visible";

    renderer = new THREE.WebGLRenderer({canvas: CANVAS, antialias: true,});
    renderer.setPixelRatio( 0.8 );

    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMapEnabled = true;

    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 14000 );
    camera.position.set(0, 500, 1000);
    camera.lookAt(0,0,0);
    camera.add( Sound.listener );

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x00B9FE );

    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener('touchstart', touchStart, false);
    document.addEventListener('touchend', touchEnd, false);
    document.addEventListener('touchmove', touchMoved, false);

    document.addEventListener('mousemove', mouseMoved, false);
    document.addEventListener('mousedown', mouseDown, false);
    document.addEventListener('mouseup', mouseUp, false);

    setUpGame();
    animate();
}

function setUpGame() {
    // UI
    LEVEL_TEXT.innerHTML = "Level "+level;
    PROGRESS_BAR.style.width = '0%';

    // Lights
    var ambientLight= new THREE.AmbientLight( 0xFFFFFF , 0.1 );
    scene.add(ambientLight);
    var dLight = new THREE.DirectionalLight( 0xFFFFFF,1 );
    dLight.position.set( -100, 500, 500 );
    scene.add(dLight);
    dLight.castShadow = true;
    var d = 500;
    dLight.shadow.camera.left = - d;
    dLight.shadow.camera.right = d;
    dLight.shadow.camera.top = d;
    dLight.shadow.camera.bottom = - d;

    dLight.shadow.camera.near = 0.01;
    dLight.shadow.camera.far = 5000;

    dLight.shadow.mapSize.x = 1024;
    dLight.shadow.mapSize.y = 1024;

    // Spawning player
    let l = level;
    if (level > 12){
        l = rand(2,12);
    }
    player = eval('new Player'+l+'()');
}

function Player1() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model1.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.x = 60;
        self.group.add(self.model);


        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.m_idle.animation);
        self.propose = self.mixer.clipAction(Anims.m_propose.animation);
        self.propose.timeScale = 0;
        self.idle.play();
        /*END*/

        // SPECIAL - 2nd char
            self.model2 = THREE.SkeletonUtils.clone(BaseModel.model1_1.fbx);
            self.model2.traverse(function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                    child.castShadow = true;
                    //child.receiveShadow = true;
                }
            });
            self.model2.position.x = -60;
            self.group.add(self.model2);
            //self.model2.rotation.y = THREE.Math.degToRad(-90);

            // ANIMATION
            self.mixer2 = new THREE.AnimationMixer(self.model2);
            self.idle2 = self.mixer2.clipAction(Anims.f_idle.animation);
            self.propose2 = self.mixer2.clipAction(Anims.f_proposed.animation);
            self.idle2.play();
        // END SPECIAL

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Make him propose!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[12].children[0].children[2].children[1].children[1].children[3].children[1].children[1].children[1].add(point)
        self.raycasterPointsArray.push(point);
        // R Hand
        //let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        //self.model.children[12].children[0].children[2].children[1].children[1].children[1].children[1].children[1].children[1].add(point2)
        //self.raycasterPointsArray.push(point2);
        // END

        // Tutorial hand
        let hand = new THREE.Mesh( new THREE.PlaneGeometry(0.6,0.5), new THREE.MeshLambertMaterial( {map: Textures.hand.texture, side: THREE.DoubleSide, transparent: true, opacity: 1, depthWrite: false, depthTest: false, } ) );
        self.model.children[12].children[0].children[2].children[1].children[1].children[3].children[1].children[1].children[1].add(hand)
        hand.position.y = 0.35;
        hand.position.x = -0.01;
        self.hand = hand;
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.propose.isRunning()){
                self.mixer.stopAllAction();
                self.propose.fadeIn(self.poseTargetTime);
                self.propose.play();
                self.progressing = true;
                self.model.rotation.y = THREE.Math.degToRad(-90);
                //self.poseProgress += 1*delta;
            }
            else {
                self.propose.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.propose.timeScale = 0;
            self.propose.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > 0.2){
            self.hand.visible = false;
        }
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            //
            self.mixer2.stopAllAction();
            self.propose2.fadeIn(0.1);
            self.propose2.play();
            //self.model2.rotation.y = THREE.Math.degToRad(-180);
            //
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);
        self.mixer2.update(delta); // 2nd char for this level

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        self.hand.lookAt(camera.position);
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player2() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2.3,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model2.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = 5;
        self.group.add(self.model);
        self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.photo = self.mixer.clipAction(Anims.f_photo.animation);
        self.photo.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Make her pose for pic!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[0].children[0].children[2].children[1].children[1].children[5].children[1].children[1].children[1].add(point)
        self.raycasterPointsArray.push(point);
        // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[0].children[0].children[2].children[1].children[1].children[1].children[1].children[1].children[1].add(point2)
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.photo.isRunning()){
                self.mixer.stopAllAction();
                self.photo.fadeIn(self.poseTargetTime);
                self.photo.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.photo.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.photo.timeScale = 0;
            self.photo.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player3() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model1_1.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.x = 25;
        self.group.add(self.model);


        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.kiss = self.mixer.clipAction(Anims.f_kiss.animation);
        self.kiss.timeScale = 0;
        self.idle.play();
        /*END*/

        // SPECIAL - 2nd char
            self.model2 = THREE.SkeletonUtils.clone(BaseModel.model1.fbx);
            self.model2.traverse(function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                    child.castShadow = true;
                    //child.receiveShadow = true;
                }
            });
            self.model2.position.x = -20;
            self.group.add(self.model2);
            //self.model2.rotation.y = THREE.Math.degToRad(-90);

            // ANIMATION
            self.mixer2 = new THREE.AnimationMixer(self.model2);
            self.idle2 = self.mixer2.clipAction(Anims.m_idle.animation);
            //self.propose2 = self.mixer2.clipAction(Anims.f_proposed.animation);
            self.idle2.play();
        // END SPECIAL

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Make her kiss him!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[5].children[0].children[1].children[1].children[1].children[2].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.kiss.isRunning()){
                self.mixer.stopAllAction();
                self.kiss.fadeIn(self.poseTargetTime);
                self.kiss.play();
                self.progressing = true;
                self.model.rotation.y = THREE.Math.degToRad(-90);
                //self.poseProgress += 1*delta;
            }
            else {
                self.kiss.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.kiss.timeScale = 0;
            self.kiss.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            //
            self.model2.rotation.y = THREE.Math.degToRad(90);
            self.model2.position.x = -30;
            //
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);
        self.mixer2.update(delta); // 2nd char for this level

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player4() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        raycasterPointsArray2: [],
        poseProgress: 0,
        progressing: false,
        poseProgress2: 0,
        progressing2: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model2.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.x = 25;
        self.group.add(self.model);


        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.sit = self.mixer.clipAction(Anims.f_sit.animation);
        self.sit.timeScale = 0;
        self.idle.play();
        /*END*/

        // SPECIAL - 2nd char
            self.model2 = THREE.SkeletonUtils.clone(BaseModel.model1.fbx);
            self.model2.traverse(function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                    child.castShadow = true;
                    //child.receiveShadow = true;
                }
            });
            self.model2.position.x = -20;
            self.group.add(self.model2);
            //self.model2.rotation.y = THREE.Math.degToRad(-90);

            // ANIMATION
            self.mixer2 = new THREE.AnimationMixer(self.model2);
            self.idle2 = self.mixer2.clipAction(Anims.m_idle.animation);
            self.sit2 = self.mixer2.clipAction(Anims.m_sit.animation);
            self.idle2.play();
        // END SPECIAL

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Make them come close!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;

            }
            if (self.progressing2){
                self.poseProgress2 += 0.1/3;

            }
            // updating UI
            let p = Math.round( (Math.abs((self.poseProgress/2)+self.poseProgress2) / Math.abs(self.poseTargetTime*1.5)) * 100);
            if (p > 100)
                p = 100;
            PROGRESS_BAR.style.width = p+'%';
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[0].children[0].children[3].add(point)
        self.raycasterPointsArray.push(point);
        // END
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model2.children[12].children[0].children[2].add(point2)
        self.raycasterPointsArray2.push(point2);
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown && self.poseProgress < self.poseTargetTime*0.5) {
            //console.log('colliding');
            if (!self.sit.isRunning()){
                self.mixer.stopAllAction();
                self.sit.fadeIn(self.poseTargetTime);
                self.sit.play();
                self.progressing = true;
                self.model.rotation.y = THREE.Math.degToRad(-90);

                if (self.model.position.x > 10){
                    self.model.position.x -= 2*delta;
                }
            }
            else {
                self.sit.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.sit.timeScale = 0;
            self.sit.stop();
            self.progressing = false;
        }



        let intersect2 = self.raycaster.intersectObjects(self.raycasterPointsArray2);
        if (intersect2.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.sit2.isRunning()){
                self.mixer2.stopAllAction();
                self.sit2.fadeIn(self.poseTargetTime);
                self.sit2.play();
                self.progressing2 = true;
                self.model2.rotation.y = THREE.Math.degToRad(90);

                if (self.model2.position.x < -10){
                    self.model2.position.x += 2.5*delta;
                }
            }
            else {
                self.sit2.timeScale = 0.1*delta;
                self.progressing2 = true;
            }
        }
        else {
            self.sit2.timeScale = 0;
            self.sit2.stop();
            self.progressing2 = false;
        }
    }
    self.levelCompleteCheck = function(){
        if ((self.poseProgress/2)+self.poseProgress2 > self.poseTargetTime*1.5 && !gameOver){
            //console.log('level Complete');
            //
            //self.model2.rotation.y = THREE.Math.degToRad(90);
            //self.model2.position.x = -30;
            //
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);
        self.mixer2.update(delta); // 2nd char for this level

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray2[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player5() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model5.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        //self.model.position.y = 5;
        self.group.add(self.model);
        //self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.m_idle.animation);
        self.yoga = self.mixer.clipAction(Anims.m_yoga.animation);
        self.yoga.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Help grandpa do some yoga!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[10].children[0].children[2].add(point)
        self.raycasterPointsArray.push(point);
        // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[10].children[0].children[2].children[1].children[1].children[0].add(point2)
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.yoga.isRunning()){
                self.mixer.stopAllAction();
                self.yoga.fadeIn(self.poseTargetTime);
                self.yoga.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.yoga.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.yoga.timeScale = 0;
            self.yoga.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player6() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model6.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = 5;
        self.group.add(self.model);
        //self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.office = self.mixer.clipAction(Anims.f_office.animation);
        self.office.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Pose for office!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[7].children[0].children[1].children[1].children[1].children[2].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[7].children[0].children[1].children[1].children[1].children[4].children[1].children[1].children[1].add(point2);
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.office.isRunning()){
                self.mixer.stopAllAction();
                self.office.fadeIn(self.poseTargetTime);
                self.office.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.office.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.office.timeScale = 0;
            self.office.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player7() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model2.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = -3;
        self.group.add(self.model);
        self.model.rotation.y = THREE.Math.degToRad(90);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.booty = self.mixer.clipAction(Anims.f_booty.animation);
        self.booty.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Show off your figure!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[0].children[0].children[2].children[1].children[1].children[5].children[1].children[1].children[1].add(point)
        self.raycasterPointsArray.push(point);
        // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[0].children[0].children[2].children[1].children[1].children[1].children[1].children[1].children[1].add(point2)
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.booty.isRunning()){
                self.mixer.stopAllAction();
                self.booty.fadeIn(self.poseTargetTime);
                self.booty.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.booty.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.booty.timeScale = 0;
            self.booty.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player8() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model8.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.x = 80;
        self.model.rotation.y = THREE.Math.degToRad(-70);
        self.group.add(self.model);


        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.m_idle.animation);
        self.point = self.mixer.clipAction(Anims.m_police.animation);
        self.point.timeScale = 0;
        self.idle.play();
        /*END*/

        // SPECIAL - 2nd char
            self.model2 = THREE.SkeletonUtils.clone(BaseModel.model8_8.fbx);
            self.model2.traverse(function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                    child.castShadow = true;
                    //child.receiveShadow = true;
                }
            });
            self.model2.position.x = -80;
            self.group.add(self.model2);
            self.model2.rotation.y = THREE.Math.degToRad(70);

            // ANIMATION
            self.mixer2 = new THREE.AnimationMixer(self.model2);
            self.idle2 = self.mixer2.clipAction(Anims.m_idle.animation);
            self.handsUp = self.mixer2.clipAction(Anims.m_policeConvict.animation);
            self.idle2.play();
        // END SPECIAL

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Stop the suspect!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[14].children[0].children[2].children[1].children[1].children[1].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.point.isRunning()){
                self.mixer.stopAllAction();
                self.point.fadeIn(self.poseTargetTime);
                self.point.play();
                self.progressing = true;


            }
            else {
                self.point.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.point.timeScale = 0;
            self.point.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            self.mixer2.stopAllAction();
            self.handsUp.fadeIn(0.1);
            self.handsUp.play();
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);
        self.mixer2.update(delta); // 2nd char for this level

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player9() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model9.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = 5;
        self.group.add(self.model);
        //self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.float = self.mixer.clipAction(Anims.f_float.animation);
        self.float.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Help the woman float!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[6].children[0].children[1].children[1].children[1].children[2].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // // // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[6].children[0].children[1].children[1].children[1].children[4].children[1].children[1].children[1].add(point2);
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.float.isRunning()){
                self.mixer.stopAllAction();
                self.float.fadeIn(self.poseTargetTime);
                self.float.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.float.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.float.timeScale = 0;
            self.float.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player10() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model10.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = 0;
        self.group.add(self.model);
        //self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.pose2 = self.mixer.clipAction(Anims.f_pose2.animation);
        self.pose2.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Pose the gymnast", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[3].children[0].children[1].children[1].children[1].children[2].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // // // // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[3].children[0].children[1].children[1].children[1].children[4].children[1].children[1].children[1].add(point2);
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.pose2.isRunning()){
                self.mixer.stopAllAction();
                self.pose2.fadeIn(self.poseTargetTime);
                self.pose2.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.pose2.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.pose2.timeScale = 0;
            self.pose2.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player11() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model11.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.x = 25;
        self.group.add(self.model);


        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.f_idle.animation);
        self.kiss = self.mixer.clipAction(Anims.f_kiss.animation);
        self.kiss.timeScale = 0;
        self.idle.play();
        /*END*/

        // SPECIAL - 2nd char
            self.model2 = THREE.SkeletonUtils.clone(BaseModel.model10.fbx);
            self.model2.traverse(function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                    child.castShadow = true;
                    //child.receiveShadow = true;
                }
            });
            self.model2.position.x = -20;
            self.group.add(self.model2);
            //self.model2.rotation.y = THREE.Math.degToRad(-90);

            // ANIMATION
            self.mixer2 = new THREE.AnimationMixer(self.model2);
            self.idle2 = self.mixer2.clipAction(Anims.f_idle.animation);
            //self.propose2 = self.mixer2.clipAction(Anims.f_proposed.animation);
            self.idle2.play();
        // END SPECIAL

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Make them kiss!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[11].children[0].children[1].children[1].children[1].children[2].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // // R Hand
        // let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        // self.model.children[5].children[0].children[1].children[1].children[1].children[4].children[1].children[1].children[1].add(point2);
        // self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.kiss.isRunning()){
                self.mixer.stopAllAction();
                self.kiss.fadeIn(self.poseTargetTime);
                self.kiss.play();
                self.progressing = true;
                self.model.rotation.y = THREE.Math.degToRad(-90);
                //self.poseProgress += 1*delta;
            }
            else {
                self.kiss.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.kiss.timeScale = 0;
            self.kiss.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            //
            self.model2.rotation.y = THREE.Math.degToRad(90);
            self.model2.position.x = -30;
            //
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);
        self.mixer2.update(delta); // 2nd char for this level

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function Player12() {
    var self = {
        group: null,
        model: null,
        mixer: null,
        raycaster: new THREE.Raycaster(),
        raycasterPointsArray: [],
        poseProgress: 0,
        progressing: false,
        poseTargetTime: 2,

        tempVec1: new THREE.Vector3(),
        tempVec2: new THREE.Vector3(),
        tempVec3: new THREE.Vector3(),
    }
    self.init = function(){
        // model
        self.group = new THREE.Object3D();
        scene.add(self.group);

        self.model = THREE.SkeletonUtils.clone(BaseModel.model8.fbx);
        self.model.traverse(function ( child ) {
            if ( child instanceof THREE.Mesh ) {
                const oldMat = child.material;
                child.material = new THREE.MeshLambertMaterial( { color: oldMat.color, skinning: true });
                child.castShadow = true;
                //child.receiveShadow = true;
            }
        });
        self.model.position.y = 0;
        self.group.add(self.model);
        //self.group.rotation.y = THREE.Math.degToRad(20);

        // ANIMATION
        self.mixer = new THREE.AnimationMixer(self.model);
        self.idle = self.mixer.clipAction(Anims.m_idle.animation);
        self.exercise = self.mixer.clipAction(Anims.m_exercise.animation);
        self.exercise.timeScale = 0;
        self.idle.play();
        /*END*/

        // LEVEL GOAL TEXT
        self.goalText = new TextSprite("Do Pushups!", '#23EE82', 0.8).nameSprite;
        scene.add(self.goalText);
        self.goalText.position.y = 215;
        // END

        // ground
        let ground = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#68ECFF', '#00B9FE']]) } ) );
        ground.receiveShadow = true;
        ground.rotation.x = THREE.Math.degToRad(-90);
        scene.add( ground );
        let back = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000 ), new THREE.MeshLambertMaterial( { map:gradTexture([[0.4,0.1], ['#00B9FE', '#00B9FE']]) } ) );
        back.receiveShadow = true;
        back.position.z = -2500;
        scene.add( back );
        // END


        // PROGRESS COUNTER
        self.poseProgressInterval = setInterval(function(){
            if (self.progressing){
                self.poseProgress += 0.1/3;
                // updating UI
                let p = Math.round( (Math.abs(self.poseProgress) / Math.abs(self.poseTargetTime)) * 100);
                if (p > 100)
                    p = 100;
                PROGRESS_BAR.style.width = p+'%';
            }
        },100)
        // END

        // RAYCAST POINTS
        // L hand
        let point = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[14].children[0].children[2].children[1].children[1].children[3].children[1].children[1].children[1].add(point);
        self.raycasterPointsArray.push(point);
        // // R Hand
        let point2 = new THREE.Mesh( new THREE.CircleGeometry(0.08,16), new THREE.MeshLambertMaterial( {map: Textures.circle.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthWrite: false, depthTest: false, } ) );
        self.model.children[14].children[0].children[2].children[1].children[1].children[1].children[1].children[1].children[1].add(point2);
        self.raycasterPointsArray.push(point2);
        // END
    }
    self.checkRaycaster = function(delta) {
        //if (!mouseIsDown) return;

        self.raycaster.setFromCamera(mouse, camera);
        let intersect = self.raycaster.intersectObjects(self.raycasterPointsArray);
        if (intersect.length > 0 && mouseIsDown) {
            //console.log('colliding');
            if (!self.exercise.isRunning()){
                self.mixer.stopAllAction();
                self.exercise.fadeIn(self.poseTargetTime);
                self.exercise.play();
                self.progressing = true;
                //self.poseProgress += 1*delta;
            }
            else {
                self.exercise.timeScale = 0.1*delta;
                self.progressing = true;
            }
        }
        else {
            self.exercise.timeScale = 0;
            self.exercise.stop();
            self.progressing = false;
        }
    }
    self.levelCompleteCheck = function(){
        if (self.poseProgress > self.poseTargetTime && !gameOver){
            //console.log('level Complete');
            gameOver = true;
            for (let i in self.raycasterPointsArray){
                self.raycasterPointsArray[i].visible = false;
            }
            clearInterval(self.poseProgressInterval);
            gameOverFunction();
        }
    }
    self.update = function(delta) {
        self.mixer.update(delta);

        // gameplay
        self.checkRaycaster(delta);
        self.levelCompleteCheck();

        // raycast points always face camera like sprite
        for (let i in self.raycasterPointsArray){
            self.raycasterPointsArray[i].lookAt(camera.position);
        }
        // CAMERA follow
        var worldPos = self.group.getWorldPosition(self.tempVec1);
        worldPos.z += 500;
        worldPos.y += 200;
        camera.position.lerp(worldPos, 1.5*delta);
        let pos = self.group.position.clone();
        pos.y += 100;
        camera.lookAt(pos);
    }

    self.init();
    updateArray.push(self);
    return self;
}

function gameOverFunction() {
    setTimeout(function(){
        GAMEOVER_UI.style.visibility = "visible";
    },2500)

    Sound.levelComplete.sound.play();
    callConfetti();
    level ++;
    GO_MESSAGE.innerHTML = "Level Complete!";
    BTN_RESTART.style.display = "none";
    BTN_NEXT.style.display = "inline-block";
    // Lagged API achievements
    var ach=false;
    var ach_numb=[];
    if(level > 2){
        ach=true;
        ach_numb.push("move_peoplepuzzles_chdfj001");
    }
    if(level > 5){
        ach=true;
        ach_numb.push("move_peoplepuzzles_chdfj002");
    }
    if(level > 10){
        ach=true;
        ach_numb.push("move_peoplepuzzles_chdfj003");
    }
    if(ach){
        LaggedAPI.Achievements.save(ach_numb, function(response) {
            if(response.success) {
                console.log('achievement saved')
            }else {
                console.log(response.errormsg);
            }
        });
    }
    // Save
    try{
        localStorage.setItem("MovePeopleLaggedSavedd",level);
    }catch(e){
      console.log(e);
    }
}

function reset() {
    for( var i = scene.children.length - 1; i >= 0; i--)
        scene.remove(scene.children[i]);

    player = null;
    updateArray = [];
    gameOver = false;
    mouseIsDown = false;
    GAMEOVER_UI.style.visibility = "hidden";
}

// BUTTONS
function btnGO() {
    Sound.button.sound.play();
    // Lagged API show ad on after game over screen interaction
    if (Sound.music.sound.isPlaying)
        Sound.music.sound.pause();
    LaggedAPI.APIAds.show(function() {
        // ad is finished, unpause game/music
        console.log("ad completed");
        if (!Sound.music.sound.isPlaying)
            Sound.music.sound.play();
        // start new level below
        reset();
        setUpGame();
    });
}

function btnLoader() {
    Sound.button.sound.play(); // !!! Important. Dont't remove. It is to avoid The AudioContext was not allowed to start console messages, and smoothly trigger audio on user interaction just how the browsers nowadays like it
    LaggedAPI.APIAds.show(function() {
        // ad is finished, unpause game/music
        console.log("ad completed");
        init();
        // hide the loading bar
        const loadingElem = document.querySelector('#loading');
        loadingElem.style.display = 'none';
        LOADER_BUTTON.style.display = 'none';
        Sound.music.sound.play();
    });
}

function btnSound() {
    Sound.button.sound.play();
    if (BTN_SOUND.style.opacity == 1){
        BTN_SOUND.style.opacity = 0.5;
        Sound.listener.setMasterVolume(0);
    }
    else {
        BTN_SOUND.style.opacity = 1;
        Sound.listener.setMasterVolume(1);
    }
}

// CONTROLS
var mouse = new THREE.Vector2();
var mouseVec3 = new THREE.Vector3();
var mouseIsDown = false;

function touchStart(event) {
    let touch = event.changedTouches[0];
    mouseIsDown = true;
}

function touchEnd(event) {
    mouseIsDown = false;
}

function touchMoved(event) {
    let touch = event.changedTouches[0];
    mouse.x = (touch.pageX / window.innerWidth) * 2 - 1;
    mouse.y = -(touch.pageY / window.innerHeight) * 2 + 1;
}

function mouseDown(event) {
    mouseIsDown = true;
}

function mouseUp(event) {
    mouseIsDown = false;
}

function mouseMoved(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

// ACTUAL GAME
function animate(){
    requestAnimationFrame( animate );
    var delta = clock.getDelta();
    if (delta > 0.2)
        delta = 0;

    for (let i in updateArray){
        updateArray[i].update(delta);
    }

    showLandscapeMessage();
    renderer.render( scene, camera );
}
preload();

// HELPER AND EXTRA STUFF
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
}

function rand(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive
}

function showLandscapeMessage() { // portrait on mobile
    if (onMobile) {
        if (window.innerWidth > window.innerHeight){
            ROTATE_MSG.style.visibility = "visible";
        }
        else if (ROTATE_MSG.style.visibility == "visible"){
            ROTATE_MSG.style.visibility = "hidden";
        }
    }
}

function is_touch_device() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e) {
    return false;
  }
}

function callConfetti() {
    var duration = 2 * 40;
    var end = Date.now() + duration;

    (function frame() {
        // launch a few confetti from the left edge
        confetti({
            particleCount: 10,
            angle: 60,
            spread: 55,
            origin: { x: 0 }
        });
        // and launch a few from the right edge
        confetti({
            particleCount: 10,
            angle: 120,
            spread: 55,
            origin: { x: 1 }
        });
        // and launch a few from the middle
        confetti({
            particleCount: 10,
            angle: 90,
            spread: 100,
            origin: { x: 0.5, y: 0.7 }
        });

        // keep going until we are out of time
        if (Date.now() < end) {
            requestAnimationFrame(frame);
        }
    }());

    confetti({
        particleCount: 150,
        spread: 180
    });
}

function TextSprite (text, textColor, scale) {
    var self = {

    }
    self.init = function(){
        const ctx = document.createElement('canvas').getContext('2d');
        const borderSize = 2;
        const font =  `1000 30px Arial`;
        ctx.font = font;
        // measure how long the name will be
        const textWidth = ctx.measureText(text).width;
        const doubleBorderSize = borderSize * 2;
        const width = 200 + doubleBorderSize;
        const height = 200 + doubleBorderSize;
        ctx.canvas.width = width;
        ctx.canvas.height = height;
        ctx.font = font;

        // need to set font again after resizing canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        // scale to fit but don't stretch
        const scaleFactor = Math.min(1, 200 / textWidth);
        ctx.translate(width / 2, height / 2);
        ctx.scale(scaleFactor, 1);
        if (textColor)
            ctx.fillStyle = textColor;
        else
            ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeText(text, 0, 0);
        ctx.fillText(text, 0, 0);

        const texture = new THREE.CanvasTexture(ctx.canvas);
        texture.encoding = THREE.sRGBEncoding;
        texture.minFilter = THREE.LinearFilter;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        spriteMaterial = new THREE.SpriteMaterial({map:texture, depthTest: false});
        self.nameSprite = new THREE.Sprite(spriteMaterial);
        const labelBaseScale = 0.01;
        if (!scale){
            self.nameSprite.scale.x =  width*1.4;
            self.nameSprite.scale.y =  height*1.3;
        }
        else {
            self.nameSprite.scale.x =  width*scale;
            self.nameSprite.scale.y =  height*(scale*0.7);
        }
    }

    self.init();
    return self;
}

function gradTexture(color) {
    var c = document.createElement("canvas");
    var ct = c.getContext("2d");
    var size = 1024;
    c.width = 16; c.height = size;
    var gradient = ct.createLinearGradient(0,0,0,size);
    var i = color[0].length;
    while(i--){ gradient.addColorStop(color[0][i],color[1][i]); }
    ct.fillStyle = gradient;
    ct.fillRect(0,0,16,size);
    var texture = new THREE.Texture(c);
    texture.needsUpdate = true;
    texture.encoding = THREE.sRGBEncoding;
    return texture;
}

</script>
</body>
</html>
