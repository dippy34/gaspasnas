<html>

<head><script>(function(w,i,g){w[g]=w[g]||[];if(typeof w[g].push=='function')w[g].push(i)})
(window,'AW-1055364430','google_tags_first_party');</script><script async src="/925q/"></script>
			<script>
				window.dataLayer = window.dataLayer || [];
				function gtag(){dataLayer.push(arguments);}
				gtag('js', new Date());
				gtag('set', 'developer_id.dYzg1YT', true);
				gtag('config', 'AW-1055364430');
			</script>
			

<!--Meta stuff-->

<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"/>

<script src="js/v3-api.js"></script>

<title>Hair Dash Challenge</title>

<style>

    * {

        -moz-box-sizing: border-box;

        -webkit-box-sizing: border-box;

        box-sizing: border-box;

        font-family: sans-serif;

        font-weight: 400;

        outline: none;

        user-select: none;

    }

    body {

        margin: 0;

        overflow: hidden;

    }

    #loading {

        position: fixed;

        left: 0;

        top: 0;

        width: 100%;

        height: 100%;

        color: white;

        text-align: center;

        font-size: 30px;

        font-weight: 100;

        background-color: #4153A5;

        text-shadow:         /* create a black outline */

        -1px -1px 0 #000,

         0   -1px 0 #000,

         1px -1px 0 #000,

         1px  0   0 #000,

         1px  1px 0 #000,

         0    1px 0 #000,

        -1px  1px 0 #000,

        -1px  0   0 #000;



    }

    #loading>div {

        margin-top: 30vh;

    }

    .progress {

        margin-top: 1vh;

        display: inline-block;

        border-radius: 10vw;

        width: 50vw;

        height: 1.5vw;

        background-color: #2B292A;

    }

    #progressbar {

        width: 0;

        border-radius: 10vw;

        height: 1.5vw;

        background: rgb(253,105,41);

        background: -moz-linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);

        background: -webkit-linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);

        background: linear-gradient(90deg, rgba(253,105,41,1) 19%, rgba(244,192,41,1) 100%);

        filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#fd6929",endColorstr="#f4c029",GradientType=1);

    }

    #lagged {

        margin-bottom: 10vh;

        display: inline-block;

        width: 30vh;

        height: 30vh;

        background-image: url(Images/lagged.png);

        background-repeat: no-repeat;

        background-size:contain;

    }

    #c {

        position: fixed;

        left: 0;

        top: 0;

        width: 100%;

        height: 100%;

        display: block;

    }

    #btnSound {

        position: fixed;

        left: 0.5%;

        top: 1%;

        width: 8%;

        height: 8%;

        visibility: hidden;

        background-image: url(Images/btnSound.png);

        background-repeat: no-repeat;

        background-size:contain;

    }

    .button {

        transition: all .1s;

        cursor: pointer;

        user-select: none;

    }

    .button:hover {

        transform: scale(1.1);

    }

    #instruction {

        visibility: hidden;

    }

    #bar {

        position: fixed;

        width: 20%;

        height: 10%;

        bottom: 2%;

        left:0;

        right:0;

        margin: 0 auto;



        background-image: url(Images/slide.png);

        background-repeat: no-repeat;

        background-size:contain;

    }

    #hand {

        width: 40%;

        height: 10%;

        position: fixed;

        bottom: 2%;

        left: 48%;



        background-image: url(Images/hand.png);

        background-repeat: no-repeat;

        background-size:contain;

        animation: leftRightAnim 2s linear infinite;

    }

    @keyframes leftRightAnim {

        33% {transform: translateX(20%);}

        66% {transform: translateX(-20%);}

    }

    #ingameLagged {

        display: inline-block;

        width: 25vh;

        height: 12vh;

        background-image: url(Images/lagged2.png);

        background-repeat: no-repeat;

        background-size:contain;



    }

    #gameUI {

        position: fixed;

        text-align: center;

        width: 100%;

        height: 100%;

        left: 0;

        top: 0;

        visibility: hidden;

    }

    #lvlNo {

        display: inline-block;

        margin-top: -2vh;

        text-align: center;

        color: white;

        font-size: 300%;

        font-weight: 800;

        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,         /* create a black outline */

        -1px -1px 0 #000,

         0   -1px 0 #000,

         1px -1px 0 #000,

         1px  0   0 #000,

         1px  1px 0 #000,

         0    1px 0 #000,

        -1px  1px 0 #000,

        -1px  0   0 #000;



    }

    #scoreText {

        position: fixed;

        padding: 0 2%;

        right: 0.5%;

        top: 0.5%;

        text-align: center;

        color: yellow;

        font-size: 350%;

        font-weight: 800;

        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,         /* create a black outline */

        -1px -1px 0 #000,

         0   -1px 0 #000,

         1px -1px 0 #000,

         1px  0   0 #000,

         1px  1px 0 #000,

         0    1px 0 #000,

        -1px  1px 0 #000,

        -1px  0   0 #000;

       background-color: rgba(0,0,0,0.5);

       border-radius: 25px;

    }

    #gameOverUI {

        position: fixed;

        left: 0;

        top: 0;

        width: 100%;

        height: 100%;

        text-align: center;

        visibility: hidden;

        background-color: rgba(0,0,0,0.5);

    }

    #moreGames {

        display: inline-block;

        width: 400px;

        height: 400px;

        background-color: rgba(0,0,0,0.5);

        color: white;

        margin-top: 1.2%;

    }

    /* add #moreGames h3 and .thumbWrapper style ~lagged template */

    #moreGames h3{float:left;clear:both;width:100%;line-height:16px;height:16px;font-size:16px;font-weight:600;padding-top:3px}

    .thumbWrapper{overflow:hidden;position:relative;background-color:#a5a5a5;box-shadow:0 0 4px 0 rgba(0,0,0,.5);margin:3% 0 0 5%;width:43%;padding-bottom:43%;border-radius:5px}.thumbWrapper div{top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:5px}.thumbWrapper a{top:0;left:0;bottom:0;right:0;z-index:200;text-indent:-99999px}.thumbWrapper img{width:100%;height:100%;border-radius:2px}.thumbWrapper span.thumbname{position:absolute;transition:bottom .6s ease;font-size:15px;font-weight:700;letter-spacing:1px;width:100%;bottom:-125%;left:0;height:auto;min-height:18px;line-height:20px;padding:7px 0 4px;text-align:center;text-transform:uppercase;background-color:rgba(42,100,144,.8);color:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px}.thumbWrapper:hover span{display:block}



    #btnNext{

        display: inline-block;

        padding: 0 0.5%;

        border-radius: 20px;

        margin-top: 19vh;

        background-color: springgreen;



        color: white;

        font-size: 320%;

        font-weight: 800;

        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,

        -1px -1px 0 #000,

         0   -1px 0 #000,

         1px -1px 0 #000,

         1px  0   0 #000,

         1px  1px 0 #000,

         0    1px 0 #000,

        -1px  1px 0 #000,

        -1px  0   0 #000;

        line-height: 80px;

    }

    #goMessage {

        color: white;

        font-size: 300%;

        font-weight: 800;



        display: inline-block;

        margin-top: 1%;

        text-shadow: 0px 4px 0px rgba(0, 0, 0, 0.6),2px 2px 4px #000000,

        -1px -1px 0 #000,

         0   -1px 0 #000,

         1px -1px 0 #000,

         1px  0   0 #000,

         1px  1px 0 #000,

         0    1px 0 #000,

        -1px  1px 0 #000,

        -1px  0   0 #000;

    }

    #rotateDeviceBG {

        background-color: rgba(0,0,0,1);

        position: fixed;

        width: 100%;

        height: 100%;

        text-align: center;

        visibility: hidden;

    }

    .phone {

        position: fixed;

        height: 100px;

        width: 200px;

        border: 4px solid white;

        border-radius: 10px;

        animation: rotate 1.5s ease-in-out infinite alternate;

        left: 38%;

        top: 25%;

        /* display: none; */

    }



    .message {

        position: fixed;

        left: 40%;

      color: white;

      font-size: 1em;

      bottom: 15%;

      /* display: none; */

    }



    @keyframes rotate {

      0% {

            transform: rotate(0deg)

        }

        50% {

            transform: rotate(-90deg)

        }

        100% {

            transform: rotate(-90deg)

        }

    }

    @media only screen and (max-width: 700px) {

        #loading {

            font-size: 20px;

        }

        .progress {

            width: 70vw;

        }

        #moreGames {

            width: 350px;

            height: 350px;

            margin-top: 5%

        }

        #goMessage {

            font-size: 250%;

            font-weight: 700;

            margin-top: 30%

        }

        #btnNext{

            font-size: 170%;

        }

        #lvlNo {

            font-size: 250%;

            font-weight: 800;

        }

        #scoreText {

            font-size: 180%;

            font-weight: 800;

        }

        #btnSound {

            width: 11%;

            height: 11%;

        }

        #ingameLagged {

            width: 20vh;

            height: 10vh;

        }

        #bar {



            width: 40%;

            height: 20%;

            bottom: -8%;



        }

        #hand {

            width: 30%;

            height: 10%;

        }

    }



</style>



</head>

<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r113/three.min.js"></script>

<script src="./Libs/ammo.js"></script>

<script src="./Libs/FBXLoader.js"></script>

<script src="./Libs/inflate.min.js"></script>

<script src="./Libs/SkeletonUtils.js"></script>

<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>



<div id="loading">

    <div>

        <div id="lagged"></div>

        <div id="progressText">0%</div>

        <div class="progress"><div id="progressbar"></div></div>

        <div>Loading...</div>

    </div>

</div>



<canvas id="c"></canvas>



<div id="instruction">

    <div id="bar"></div>

    <div id="hand"></div>

</div>



<div id="gameUI">

    <div id="ingameLagged"></div><br>

    <div id="lvlNo">Level 1</div><br>

    <div id="scoreText" class="animate__faster">00</div><br>

</div>



<div id="gameOverUI">



    <div id="btnNext" onclick="btnContinue()" class="button">Continue &raquo;</div><br>

    <div id="moreGames">



<!--can use these defaults for more games ~lagged template-->



      <h3>More Games</h3>

      <div class="thumbWrapper newboxshadow firstgame"><div>

      <a href="https://lagged.com/en/g/high-heels-2" target="_blank">High Heels 2</a>

      <img src="https://imgs2.dab3games.com/high-heels-211.png" width="200" height="200" alt="game" />

      <span class="thumbname"><span>High Heels 2</span></span>

      </div></div>

      <div class="thumbWrapper newboxshadow"><div>

      <a href="https://lagged.com/en/g/funny-hair-cut" target="_blank" title="game">Funny Haircut</a>

      <img src="https://imgs2.dab3games.com/funny-haircut-game.png" width="200" height="200" alt="game" />

      <span class="thumbname"><span>Funny Haircut</span></span>

      </div></div>



    <div class="thumbWrapper newboxshadow"><div>

    <a href="https://lagged.com/en/g/minecraft-online" target="_blank" title="game">Minecraft Online</a>

    <img src="https://imgs2.dab3games.com/minecraft-online-game.jpg" width="200" height="200" alt="game" />

    <span class="thumbname"><span>Minecraft Online</span></span>

    </div></div>



    <div class="thumbWrapper newboxshadow"><div>

    <a href="https://lagged.com/en/g/high-heels-online" target="_blank">High Heels Online</a>

    <img src="https://imgs2.dab3games.com/high-heels-online-game364.png" width="200" height="200" alt="game" />

    <span class="thumbname"><span>High Heels Online</span></span>

    </div></div>



  </div>





    <br>





    <div id="goMessage" class="animate__animated animate__tada animate__infinite">Level Complete!</div><br>

</div>



<div id="btnSound"  class="button" onclick="btnSound()"></div>



<div id="rotateDeviceBG">

    <div class="phone">

    </div>

    <div class="message">

      Please rotate your device!

    </div>

</div>



<script>

// GLOBAL VAR

//console.warn = function(){};

var scene = null;

var camera = null;

var renderer = null;

var clock = new THREE.Clock();



var updateArray = [];

var playerModel = {};

var player = null;

var spawner = null;

var collisionArray = [];

try{

var level = parseInt(localStorage.getItem("hairDashChallenge"));

}catch(e){

  console.log(e);

}

if (!level > 0)

level = 1;

var gameOver = false;

var score = 0;

var particleArray = [];

var onMobile = false;



//physics

var physicsWorld = null;

var rigidBodies = [];

var tmpTrans, ammoTmpPos, ammoTmpQuat;

const STATE = { DISABLE_DEACTIVATION : 4 };

const FLAGS = { CF_KINEMATIC_OBJECT: 2 };



const BaseModel = {

    level0: {url: 'Models/level0.fbx'},

    level1: {url: 'Models/level1.fbx'},

    level2: {url: 'Models/level2.fbx'},

    level3: {url: 'Models/level3.fbx'},

    levelEnd: {url: 'Models/levelEnd.fbx'},

}

const Anims = {

    idle: {url: 'Models/a_idle.fbx'},

}

const Textures = {

    shadow: {url: 'Images/shadow.png'},

    girl: {url: 'Models/texturegirl.png'},

    score: {url: 'Images/plusOne.png'},

    explosion: {url: 'Images/explosion.png'},

}

const Sound = {

    music: {url: 'Sound/music.mp3'},

    button: {url: 'Sound/button.mp3'},

    complete: {url: 'Sound/complete.mp3'},

    score: {url: 'Sound/score.mp3'},

    hair: {url: 'Sound/hair.mp3'},

}



// DOM elements

const CANVAS = document.querySelector('#c');

const PROGRESS_TEXT = document.querySelector('#progressText');

const GAME_UI = document.querySelector('#gameUI');

const INSTRUCTION = document.querySelector('#instruction');

const BTN_SOUND = document.querySelector('#btnSound');

const GAMEOVER_UI = document.querySelector('#gameOverUI');

const SCORE = document.querySelector('#scoreText');

const LEVEL = document.querySelector('#lvlNo');

const ROTATE_MSG  = document.querySelector('#rotateDeviceBG');



function preload() {

    const progressbarElem = document.querySelector('#progressbar');

    let manager = new THREE.LoadingManager();

    manager.onStart = function ( url, itemsLoaded, itemsTotal ) {

        //console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

    };

    manager.onLoad = function ( ) {

        //console.log( 'Loading complete!');

        init();

        // hide the loading bar

        const loadingElem = document.querySelector('#loading');

        loadingElem.style.display = 'none';

    };

    manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {

        //console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

        progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;

        PROGRESS_TEXT.innerHTML = `${itemsLoaded / itemsTotal * 100 | 0}%`;

    };

    manager.onError = function ( url ) {

        //console.log( 'There was an error loading ' + url );

    };



    var loader = new THREE.FBXLoader( manager );

    // load base character model

    for (const model of Object.values(BaseModel)) {

        loader.load( model.url, function ( fbx ) {

            model.fbx = fbx;

        });

    }

    // load anims

    for (const model of Object.values(Anims)) {

        loader.load( model.url, function ( fbx ) {

            //model.fbx = fbx;

            model.animation = fbx.animations[ 0 ];

        });

    }

    // load textures

    var loaderTex = new THREE.TextureLoader(manager);

    for (const img of Object.values(Textures)) {

        loaderTex.load( img.url, function(texture) {

            texture.encoding = THREE.sRGBEncoding;

            img.texture = texture;

        });

    }

    // load audio

    Sound.listener = new THREE.AudioListener();

    const audioLoader = new THREE.AudioLoader( manager );

    for (const key of Object.values(Sound)) {

        audioLoader.load( key.url, function(buffer) {

            key.sound = new THREE.Audio( Sound.listener );

            key.sound.setBuffer( buffer );

            key.sound.setVolume( 2 );

            if (key.url == 'Sound/music.mp3'){

                key.sound.setLoop( true );

                key.sound.setVolume( 0.7 );

            }

        });

    }

    // load character

    loader.load( 'Models/girl3.fbx', function( object ) {

        object.traverse(function(child) {

            if (child instanceof THREE.Mesh) {



                child.material = new THREE.MeshBasicMaterial( {

                    map : Textures.girl.texture,

                    skinning: true,

                    side: THREE.DoubleSide

                });

            }



        });

        //object.scale.set(1,1,1);

        object.rotation.y += THREE.Math.degToRad(180);

        playerModel.model = object;

        playerModel.animation = object.animations[0];

    });

}



function init(){

    if (is_touch_device()){

        onMobile = true;

    }

    LEVEL.innerHTML = "Level "+level;

    BTN_SOUND.style.visibility = "visible";

    INSTRUCTION.style.visibility = "visible";

    GAME_UI.style.visibility = "visible";

    renderer = new THREE.WebGLRenderer({canvas: CANVAS, antialias: true,});

    renderer.setPixelRatio( 0.8 );



    renderer.setSize( window.innerWidth, window.innerHeight );

    renderer.outputEncoding = THREE.sRGBEncoding;

    //renderer.shadowMapEnabled = true;



    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 14000 );

    camera.position.set(0, 400, 400);

    camera.lookAt(0,140,0);

    camera.add( Sound.listener );



    scene = new THREE.Scene();

    scene.background = new THREE.Color( 0x00B9FE ).convertSRGBToLinear();



    window.addEventListener( 'resize', onWindowResize, false );

    document.addEventListener('touchstart', touchStart, false);

    document.addEventListener('touchend', touchEnd, false);

    document.addEventListener('touchmove', touchMoved, false);



    document.addEventListener('mousemove', mouseMoved, false);

    document.addEventListener('mousedown', mouseDown, false);

    document.addEventListener('mouseup', mouseUp, false);

    Ammo().then( setUpGame );

    animate();

}



function setUpGame() {

    LaggedAPI.init('hair_dashchallenge_gintaoml','lagdevaF3001');

    // physics

    setupPhysicsWorld();



    spawner = new Spawner();

    player = new Player();

}



function setupPhysicsWorld(){

    tmpTrans = new Ammo.btTransform();

    ammoTmpPos = new Ammo.btVector3();

    ammoTmpQuat = new Ammo.btQuaternion();

    let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),

        dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),

        overlappingPairCache    = new Ammo.btDbvtBroadphase(),

        solver                  = new Ammo.btSequentialImpulseConstraintSolver();



    physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);

    physicsWorld.setGravity(new Ammo.btVector3(0, -100, 0));

}



function Player() {

    var self = {

        group: null,

        model: null,

        mixer: null,

        colShape: null,

        speed: 220,

        horizontalSpeed: 2,

        tmpPos: new THREE.Vector3(),

        tmpQuat: new THREE.Quaternion(),

        hairArray: [],

        currentIndex: 0,

        worldPos: new THREE.Vector3(),

        followCamera: true,

        hairLength: 2,

        spawnTimer: 0,

    }

    self.init = function(){

        // model

        self.group = new THREE.Object3D();

        scene.add(self.group);



        self.model = THREE.SkeletonUtils.clone(playerModel.model);

        self.model.position.set(0, -95, 0);

        self.group.add(self.model);

        //self.model.position.y = -10;



        self.mixer = new THREE.AnimationMixer(self.model);

        const firstClip = playerModel.animation;

        self.walk = self.mixer.clipAction(firstClip);

        const secondClip = Anims.idle.animation;

        self.idle = self.mixer.clipAction(secondClip);

        self.idle.play();



        //Shadow

        self.shadow = new THREE.Mesh( new THREE.CircleGeometry(75, 5, 15), new THREE.MeshBasicMaterial({ map: Textures.shadow.texture, transparent: true, opacity: 0.16 }));

        self.shadow.rotation.x = -1.57;

        self.group.add(self.shadow);

        self.shadow.position.z -= 5;

        self.shadow.position.x -= 10;

        self.shadow.position.y = -94;



        // physics

        let pos = {x: 0, y: 100, z: 0};

        let width = 30;

        let height = 300;

        let depth = 5;

        let quat = {x: 0, y: 0, z: 0, w: 1};

        let mass = 1;

        //Visible box for physics

        self.box = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x30ab78, visible: false}));



        self.group.position.set(pos.x, pos.y, pos.z);

        self.box.scale.set(50, height, 50);

        self.group.add(self.box);



        self.boundingBox = new THREE.BoxHelper(self.box, 0x00ff00);

        self.box3 = new THREE.Box3().setFromObject(self.box);

        //scene.add(self.boundingBox);



        // physics shape

        let transform = new Ammo.btTransform();

        transform.setIdentity();

        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );

        transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );

        let motionState = new Ammo.btDefaultMotionState( transform );



        let colShape = new Ammo.btBoxShape( new Ammo.btVector3( width * 0.5 , height * 0.5 , width * 0.5 ) );

        colShape.setMargin( 0.05 );



        let localInertia = new Ammo.btVector3( 0, 0, 0 );

        colShape.calculateLocalInertia( mass, localInertia );



        let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );

        let body = new Ammo.btRigidBody( rbInfo );

        body.setActivationState( STATE.DISABLE_DEACTIVATION );

        body.setCollisionFlags( FLAGS.CF_KINEMATIC_OBJECT );

        //body.linearDamping = 0;

        //body.setAngularFactor( 0, 0, 0 );

        physicsWorld.addRigidBody( body );

        self.physicsBody = body;

        //rigidBodies.push(self);

        self.createHair(true);

        for (let i =0; i < 30; i++){

            self.createHair();

        }

    }

    self.createHair = function(first){

        let pos = {x: 0, y: 190, z: 0};

        let radius = 15;

        let quat = {x: 0, y: 0, z: 0, w: 1};

        let mass = 0.5;

        pos.z = 30+10*self.currentIndex;



        //threeJS Section

        let block = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshBasicMaterial({color: new THREE.Color( 0xFFA814 ).convertSRGBToLinear()}));



        block.group = new THREE.Object3D();

        scene.add(block.group);

        block.group.add(block);

        block.group.canRotate = true;

        block.group.position.set(pos.x, pos.y, pos.z);



        block.boundingBox = new THREE.BoxHelper(block, 0x00ff00);

        block.box3 = new THREE.Box3().setFromObject(block);

        //scene.add(block.boundingBox);



        //Ammojs Section

        let transform = new Ammo.btTransform();

        transform.setIdentity();

        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );

        transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );

        let motionState = new Ammo.btDefaultMotionState( transform );



        let colShape = new Ammo.btSphereShape( radius );

        colShape.setMargin( 0.05 );



        let localInertia = new Ammo.btVector3( 0, 0, 0 );

        colShape.calculateLocalInertia( mass, localInertia );



        let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );

        let body = new Ammo.btRigidBody( rbInfo );



        var linearDamping = 0.5;

        var angularDamping = 0.5;

        body.setDamping(linearDamping, angularDamping);

        //body.linearDamping = 0;

        //body.setAngularFactor( 0, 0, 0 );

        physicsWorld.addRigidBody( body );

        self.hairArray.push(body);

        body.block = block;

        body.c_index = self.currentIndex;



        block.physicsBody = body;

        rigidBodies.push(block);



        //Create Joints

        //let bodyPivot = new Ammo.btVector3( 5, 240*0.5, 20 );

        //let hairPivot = new Ammo.btVector3( 15, 1, 1 );



        //let p2p = new Ammo.btPoint2PointConstraint( self.physicsBody, body, bodyPivot, hairPivot);

        //physicsWorld.addConstraint( p2p, false );

        if (first){

            const pivotA = new Ammo.btVector3( 0, 200 * 0.5, 5 );

            const pivotB = new Ammo.btVector3( 0, - 0.2,0  );

            const axis = new Ammo.btVector3( 0, 0, 1 );

            hinge = new Ammo.btHingeConstraint( self.physicsBody, body, pivotA, pivotB, axis, axis, true );

            physicsWorld.addConstraint( hinge, true );

            //Create Joints

            /*let spherePivot = new Ammo.btVector3( 0, 100, 0 );

            let blockPivot = new Ammo.btVector3( radius * 0.5, 0, 0 );



            let p2p = new Ammo.btPoint2PointConstraint( self.physicsBody, body, spherePivot, blockPivot);

            physicsWorld.addConstraint( p2p, true );*/

        }

        else {

            const pivotA = new Ammo.btVector3( 0, 15 * 0.5, 13 );

            const pivotB = new Ammo.btVector3( 0, - 0.2, 0);

            const axis = new Ammo.btVector3( 0, 0, 1 );

            hinge = new Ammo.btHingeConstraint( self.hairArray[self.currentIndex-1], body, pivotA, pivotB, axis, axis, true );

            physicsWorld.addConstraint( hinge, true );

        }

        if (self.currentIndex > 0)

            block.visible = false;

        self.currentIndex ++;



    }

    self.sortHair = function(){

        for (let i in self.hairArray){

            if (i < self.hairLength){

                self.hairArray[i].block.visible = true;

                let v = new THREE.Vector3();

                self.hairArray[i].block.getWorldPosition(v);

                new explosion(v);

            }

            else {

                self.hairArray[i].block.visible = false;

            }

        }

    }

    self.checkCollision = function(){

        for (let a in self.hairArray){

            for (let i in collisionArray){

                let child = collisionArray[i];

                collision = self.hairArray[a].block.box3.intersectsBox(child);

                if (collision){

                    if (child.saw && self.hairArray[a].block.visible){

                        self.hairLength = self.hairArray[a].c_index;

                        self.sortHair();

                        if (Sound.hair.sound.isPlaying)

                            Sound.hair.sound.stop();

                        Sound.hair.sound.play();

                    }

                }

            }

        }



        for (let i in collisionArray){

            let child = collisionArray[i];

            collision = self.box3.intersectsBox(child);

            if (collision){

                if (child.pickup){

                    INSTRUCTION.style.visibility = "hidden";

                    self.hairLength += 3;

                    self.sortHair();

                    collisionArray[i].destroy = true;

                    if (Sound.hair.sound.isPlaying)

                        Sound.hair.sound.stop();

                    Sound.hair.sound.play();

                }

                else if (child.end && !gameOver){

                    gameOverFunction();

                    Sound.complete.sound.play();

                }

            }

        }

    }

    self.update = function(delta) {

        self.mixer.update(delta);

        if (move.movementX > 200)

            move.movementX = 200;

        if (move.movementX < -200)

            move.movementX = -200;

        if (move.movementX > 20 && self.group.position.x < 290 && !gameOver){

            self.group.translateX((self.horizontalSpeed*move.movementX) * delta);

        }

        else if (move.movementX < -20 && self.group.position.x > -290 && !gameOver){

            self.group.translateX((self.horizontalSpeed*move.movementX) * delta);

        }

        if (move.lastX && !gameOver){

            self.group.translateZ(-self.speed * delta);

            //self.sortHair();

            if (!self.walk.isRunning()){

                self.mixer.stopAllAction();

                self.walk.fadeIn(0.2);

                self.walk.play();

            }

        }

        else if (!self.idle.isRunning()){

            self.mixer.stopAllAction();

            self.idle.fadeIn(0.2);

            self.idle.play();

        }

        self.group.getWorldPosition(self.tmpPos);

        self.group.getWorldQuaternion(self.tmpQuat);

        let ms = self.physicsBody.getMotionState();

        if ( ms ) {

            ammoTmpPos.setValue(self.tmpPos.x, self.tmpPos.y, self.tmpPos.z);

            ammoTmpQuat.setValue( self.tmpQuat.x, self.tmpQuat.y, self.tmpQuat.z, self.tmpQuat.w);

            tmpTrans.setIdentity();

            tmpTrans.setOrigin( ammoTmpPos );

            tmpTrans.setRotation( ammoTmpQuat );

            ms.setWorldTransform(tmpTrans);

        }

        if (self.followCamera){

            self.group.getWorldPosition(self.worldPos);

            self.worldPos.z += 700;

            if (gameOver)

                self.worldPos.z += 400;

            self.worldPos.y += 400;

            //worldPos.x = 0;

            camera.position.lerp(self.worldPos, 2*delta);

            self.tmpPos = self.group.position.clone();

            self.tmpPos.y += 150;

            //pos.z += 1500;

            camera.lookAt(self.tmpPos);

        }



        // update bounding box

        self.boundingBox.setFromObject(self.box);

        self.box3.setFromObject(self.box);

        for (let i in self.hairArray){

            self.hairArray[i].block.boundingBox.setFromObject(self.hairArray[i].block);

            self.hairArray[i].block.box3.setFromObject(self.hairArray[i].block);

        }

        self.spawnTimer ++;

        if (self.spawnTimer>10){

            self.checkCollision();

        }

    }



    self.init();

    updateArray.push(self);

    return self;

}



function updatePhysics( deltaTime ){

    // Step world

    physicsWorld.stepSimulation( deltaTime, 10 );



    // Update rigid bodies

    for ( let i = 0; i < rigidBodies.length; i++ ) {

        let objThree = rigidBodies[ i ];

        let objAmmo = objThree.physicsBody;

        let ms = objAmmo.getMotionState();

        if ( ms ) {

            ms.getWorldTransform( tmpTrans );

            let p = tmpTrans.getOrigin();

            let q = tmpTrans.getRotation();

            objThree.group.position.set( p.x(), p.y(), p.z() );

            if(objThree.group.canRotate)

                objThree.group.quaternion.set( q.x(), q.y(), q.z(), q.w() );

        }

    }

}



function Spawner() {

    var self = {

        group: null,

        groundArray: [],

        hairPickupArray: [],

        sawArray: [],

        sawArray2: [],

        sin: 0,

        sin2: 0,

        sin3: 0,

        nextZ: 0,

        endSensor: null,

    }

    self.init = function(){

        self.spawnGround(BaseModel.level0.fbx.clone());



        let totalBlocks = 1+Math.floor(level/3);

        for (let i = 1; i <= totalBlocks; i ++){

            let r = rand(1,3);

            self.spawnGround(eval("BaseModel.level"+r+".fbx.clone()"));

        }



        self.spawnGround(BaseModel.levelEnd.fbx.clone());

    }

    self.spawnGround = function(type){

        let pos = {x: 0, y: 0, z: self.nextZ};

        let scale = {x: 620, y: 1, z: 1450};

        let quat = {x: 0, y: 0, z: 0, w: 1};

        let mass = 0;



        // ground

        self.group = new THREE.Object3D();

        scene.add(self.group);

        self.groundArray.push(self.group);



        self.model = type;

        self.group.position.set(pos.x,pos.y,pos.z);

        self.group.add(self.model);

        self.model.traverse(function ( child ) {

            if ( child instanceof THREE.Mesh ) {

                const oldMat = child.material;

                child.material = new THREE.MeshBasicMaterial( { color: oldMat.color });

                // bounding box

                if (oldMat.name == "hair"){

                    self.hairPickupArray.push(child);

                    child.cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 40, 40, 40 ), new THREE.MeshBasicMaterial( { color: 0xffaa00, visible: false} ) );

                    child.cube.position.copy(child.position);

                    self.group.add(child.cube);

                    child.boundingBox = new THREE.BoxHelper(child.cube, 0x00ff00);

                    child.box3 = new THREE.Box3().setFromObject(child.cube);

                    child.box3.pickup = true;

                    child.box3.uuid = child.uuid;

                    collisionArray.push(child.box3);

                    //scene.add(child.boundingBox);

                }

                else if (oldMat.name == "saw"){

                    self.sawArray.push(child);

                    child.cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 180, 250, 20 ), new THREE.MeshBasicMaterial( { color: 0xffaa00,visible: false} ) );

                    child.cube.position.copy(child.position);

                    self.group.add(child.cube);

                    child.boundingBox = new THREE.BoxHelper(child.cube, 0x00ff00);

                    child.box3 = new THREE.Box3().setFromObject(child.cube);

                    child.box3.saw = true;

                    collisionArray.push(child.box3);

                    //scene.add(child.boundingBox);

                }

                else if (oldMat.name == "saw2"){

                    self.sawArray2.push(child);

                    child.cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 180, 250, 20 ), new THREE.MeshBasicMaterial( { color: 0xffaa00,visible: false} ) );

                    child.cube.position.copy(child.position);

                    self.group.add(child.cube);

                    child.boundingBox = new THREE.BoxHelper(child.cube, 0x00ff00);

                    child.box3 = new THREE.Box3().setFromObject(child.cube);

                    child.box3.saw = true;

                    collisionArray.push(child.box3);

                    //scene.add(child.boundingBox);

                }

                else if (oldMat.name == "end"){

                    child.material.visible = false;

                    self.endSensor = child;

                    child.cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 800, 250, 40 ), new THREE.MeshBasicMaterial( { color: 0xffaa00,visible: false} ) );

                    child.cube.position.copy(child.position);

                    self.group.add(child.cube);

                    child.boundingBox = new THREE.BoxHelper(child.cube, 0x00ff00);

                    child.box3 = new THREE.Box3().setFromObject(child.cube);

                    child.box3.end = true;

                    collisionArray.push(child.box3);

                    //scene.add(child.boundingBox);

                }

            }

        });

        /*

        let ground_mesh = new THREE.Mesh( new THREE.BoxBufferGeometry( scale.x, scale.y, scale.z ), new THREE.MeshBasicMaterial( { color: 0xd6f6ff, } ) );

        self.group.position.set(pos.x,pos.y,pos.z);

        self.group.add( ground_mesh );*/



        let transform = new Ammo.btTransform();

        transform.setIdentity();

        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );

        transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );

        let motionState = new Ammo.btDefaultMotionState( transform );



        let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );

        colShape.setMargin( 0.05 );



        let localInertia = new Ammo.btVector3( 0, 0, 0 );

        colShape.calculateLocalInertia( mass, localInertia );



        let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );

        let body = new Ammo.btRigidBody( rbInfo );



        physicsWorld.addRigidBody( body );



        self.nextZ -= 1440

    }

    self.update = function(dt){

        self.sin += 0.05;

        self.sin2 += 0.009;

        self.sin3 += 0.003;

        for (let i in self.sawArray){

            self.sawArray[i].rotation.y += 1*dt;

            self.sawArray[i].position.x -= Math.sin(self.sin2)*(100*dt);

            self.sawArray[i].cube.position.copy(self.sawArray[i].position);

            self.sawArray[i].boundingBox.setFromObject(self.sawArray[i].cube);

            self.sawArray[i].box3.setFromObject(self.sawArray[i].cube);

        }

        for (let i in self.sawArray2){

            self.sawArray2[i].rotation.y += 1*dt;

            self.sawArray2[i].position.x -= Math.sin(self.sin3)*(100*dt);

            self.sawArray2[i].cube.position.copy(self.sawArray2[i].position);

            self.sawArray2[i].boundingBox.setFromObject(self.sawArray2[i].cube);

            self.sawArray2[i].box3.setFromObject(self.sawArray2[i].cube);

        }

        for (let i in self.hairPickupArray){

            self.hairPickupArray[i].position.y -= Math.sin(self.sin)*(60*dt);

            self.hairPickupArray[i].cube.position.copy(self.hairPickupArray[i].position);

            self.hairPickupArray[i].boundingBox.setFromObject(self.hairPickupArray[i].cube);

            self.hairPickupArray[i].box3.setFromObject(self.hairPickupArray[i].cube);



            for (let a in collisionArray){

                if (collisionArray[a].destroy){

                    if (collisionArray[a].uuid == self.hairPickupArray[i].box3.uuid){

                        console.log("remove");

                        self.hairPickupArray[i].visible = false;

                        collisionArray.splice(a,1);

                    }

                }

            }

        }

        self.endSensor.boundingBox.setFromObject(self.endSensor.cube);

        self.endSensor.box3.setFromObject(self.endSensor.cube);

    }

    self.init();

    updateArray.push(self);

    return self;

}



function gameOverFunction() {

    gameOver = true;

    callConfetti();



    let wait = 500;

    let arr = player.hairArray;

    arr.reverse();

    for (let i in arr){

        if (arr[i].block.visible){

            setTimeout(function(){

                score ++;

                scoreFX();

                let v = new THREE.Vector3();

                arr[i].block.getWorldPosition(v);

                new explosion(v);

                new ScoreText(v);

                arr[i].block.visible = false;

            },wait)

            wait +=300;

        }

    }

    wait += 1000;

    setTimeout(function(){

        GAMEOVER_UI.style.visibility = "visible";



        var boardinfo={};

        boardinfo.score=score;

        boardinfo.board='hair_dashchallenge_hsbdxij';

        LaggedAPI.Scores.save(boardinfo, function(response) {

        if(response.success) {

        console.log('high score saved')

        }else {

        console.log(response.errormsg);

        }

        });



        LaggedAPI.APIAds.show('interstitial','hair-dash-challenge','hair-dash-challenge-game.png',function(response) {

        if(response.success) {

        console.log('ad done');

        }else {

        console.log('ad error, continue');

        }

        });



    },wait)



}



function ScoreText(spawnPos) {

    var self = {

        timer: 0,

    }

    self.init = function(){

        if (Sound.score.sound.isPlaying)

            Sound.score.sound.stop();

        Sound.score.sound.play();

        let spriteMaterial = new THREE.SpriteMaterial({map:Textures.score.texture});

        self.sprite = new THREE.Sprite(spriteMaterial);

        scene.add(self.sprite);

        self.sprite.scale.set(25,30);

        spawnPos.y += 50;

        self.sprite.position.copy(spawnPos);

    }

    self.update = setInterval(function(){

        self.sprite.position.y += 3.5;

        self.timer ++;

        if (self.timer > 40){

            scene.remove(self.sprite);

            clearInterval(self.update);

        }

    },1000/60);



    self.init();

    return self;

}



function btnContinue() {

    Sound.button.sound.play();

    GAMEOVER_UI.style.visibility = "hidden";

    for( var i = scene.children.length - 1; i >= 0; i--)

        scene.remove(scene.children[i]);

    updateArray = [];

    player = null;

    spawner = null;

    collisionArray = [];

    level++;

    gameOver = false;

    particleArray = [];

    rigidBodies = [];

    setUpGame();

    LEVEL.innerHTML = "Level "+level;

    camera.position.set(0, 400, 400);

    camera.lookAt(0,140,0);

    try{

    localStorage.setItem("hairDashChallenge",level);

    }catch(e){

      console.log(e);

    }

}



function btnSound() {

    Sound.button.sound.play();

    if (BTN_SOUND.style.opacity == 1){

        BTN_SOUND.style.opacity = 0.5;

        Sound.listener.setMasterVolume(0);

    }

    else {

        BTN_SOUND.style.opacity = 1;

        Sound.listener.setMasterVolume(1);

    }

}



function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;

    camera.updateProjectionMatrix();



    renderer.setSize( window.innerWidth, window.innerHeight );

}



// HELPER FUNCTIONS

function rand(min, max) {

    min = Math.ceil(min);

    max = Math.floor(max);

    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive

}



// CONTROLS

var move = {

    movementX: null,

    lastX: null,

};



function touchStart(event) {

    let touch = event.changedTouches[0];

    move.lastX = touch.pageX;

     if (!Sound.music.sound.isPlaying){

        Sound.music.sound.play();

    }

}



function touchEnd(event) {

    move.lastX = null;

    move.movementX = 0;

}



function touchMoved(event) {

    let touch = event.changedTouches[0];

    if (move.lastX){

        move.movementX = touch.pageX - move.lastX;

    }

}



function mouseDown(event) {

   move.lastX = event.pageX;

    if (!Sound.music.sound.isPlaying){

        Sound.music.sound.play();

    }

}



function mouseUp(event) {

    move.lastX = null;

    move.movementX = 0;

}



function mouseMoved(event) {

    if (move.lastX){

        move.movementX = event.pageX - move.lastX;

    }

}



// ACTUAL GAME

function animate(){

    requestAnimationFrame( animate );

    var delta = clock.getDelta();

    if (delta > 2){

        delta = 0;

    }



    for (let i in updateArray){

        updateArray[i].update(delta);

    }

    if (player){

        if (physicsWorld)

            updatePhysics(delta);

    }

    for (let i in particleArray){

        particleArray[i].update(delta);

    }

    showLandscapeMessage();

    renderer.render( scene, camera );

}



function callConfetti() {

    var duration = 2 * 50;

    var end = Date.now() + duration;



    (function frame() {

        // launch a few confetti from the left edge

        confetti({

            particleCount: 7,

            angle: 60,

            spread: 55,

            origin: { x: 0 }

        });

        // and launch a few from the right edge

        confetti({

            particleCount: 7,

            angle: 120,

            spread: 55,

            origin: { x: 1 }

        });



        // keep going until we are out of time

        if (Date.now() < end) {

            requestAnimationFrame(frame);

        }

    }());



    confetti({

        particleCount: 150,

        spread: 180

    });

}



function scoreFX() {

    SCORE.innerHTML = score;

    SCORE.classList.add('animate__animated', 'animate__heartBeat');

    SCORE.addEventListener('animationend', removeMenu);

    function removeMenu() {

        SCORE.removeEventListener('animationend', removeMenu);

        SCORE.classList.remove('animate__animated', 'animate__heartBeat');



    }

}



function explosion(spawnPos){

    var self = {

        particles: [],

        max: 4,

        mesh: null,

        index: null,

    }

    self.init = function() {

        let geo = new THREE.Geometry();

        for(let i=0; i<self.max; i++) {

            let particle = {

                position: new THREE.Vector3(

                      0,

                      0,

                      0),

                velocity: new THREE.Vector3(

                      rand(-1, 1),

                      rand(4,8),

                      rand(-1, 1)),

                acceleration: new THREE.Vector3(0, -0.3, 0),

            }

            self.particles.push(particle)

            geo.vertices.push(particle.position)

        }

        var mat = new THREE.PointsMaterial({color:0xFFC300,size: 60, map: Textures.explosion.texture, opacity: 0.8, transparent: true, })

        self.mesh = new THREE.Points(geo,mat)

        self.mesh.position.copy(spawnPos);

        scene.add(self.mesh);

    }

    self.update = function(){

        self.particles.forEach(p => {

            p.velocity.add(p.acceleration);

            p.position.add(p.velocity);

            self.mesh.material.size -= 0.3;

        })

        self.mesh.geometry.verticesNeedUpdate = true;

        if (self.mesh.material.size < 0){

            scene.remove(self.mesh);

            for (let i in particleArray){

                if (particleArray[i].mesh.uuid == self.mesh.uuid)

                    particleArray.splice(i,1);

            }

        }

    }



    self.init();

    particleArray.push(self);

    return self;

}



function showLandscapeMessage() {

    if (onMobile) {

        if (window.innerWidth > window.innerHeight){

            ROTATE_MSG.style.visibility = "visible";

        }

        else if (ROTATE_MSG.style.visibility == "visible"){

            ROTATE_MSG.style.visibility = "hidden";

        }

    }

}



function is_touch_device() {

  try {

    document.createEvent("TouchEvent");

    return true;

  } catch (e) {

    return false;

  }

}



preload();



</script>

</body>

</html>

